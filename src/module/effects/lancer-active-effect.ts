import type { ActiveEffectDataConstructorData } from "@league-of-foundry-developers/foundry-vtt-types/src/foundry/common/data/data.mjs/activeEffectData";
import type { EffectChangeData } from "@league-of-foundry-developers/foundry-vtt-types/src/foundry/common/data/data.mjs/effectChangeData";
import { LancerActor } from "../actor/lancer-actor";
import { LANCER, STATUSES } from "../config";
import { DeployableType, EntryType } from "../enums";
import { statusConfigEffect } from "./converter";

// Chassis = mech or standard npc
export type LancerEffectTarget =
  | EntryType.PILOT
  | EntryType.MECH
  | EntryType.NPC
  | EntryType.DEPLOYABLE
  | "only_drone"
  | "only_deployable"
  | "mech_and_npc";

export interface LancerActiveEffectFlags {
  lancer: {
    // If true, then this is the effect innately generated by certain categories of items, such as frames, npc classes, etc
    // or an effect generated by the bonuses on such an item
    // These are aggressively regenerated. Do not become attached to them.
    ephemeral?: boolean;

    // If specified, disable unless this
    target_type?: LancerEffectTarget;

    // When we propagate an effect, the origin becomes the parent actor.
    // This field maintains the true original
    deep_origin?: string | null;

    // If this is a status, effect, or condition - whichever of those it is
    status_type?: "status" | "effect" | "condition";
  };
}

export interface LancerActiveEffectConstructorData extends ActiveEffectDataConstructorData {
  flags: Record<string, unknown> & LancerActiveEffectFlags;
}

export class LancerActiveEffect extends ActiveEffect {
  get _typedFlags(): LancerActiveEffectFlags {
    // TODO :remove this when flags are properly represented on effects
    // @ts-expect-error
    return this.flags;
  }

  /**
   * Determine whether this Active Effect is suppressed or not.
   */
  get isSuppressed(): boolean {
    // Check it's not just passing through
    return !this.affectsUs();
  }

  /**
   * Determine whether this Active Effect is present only to be passed to descendants
   */
  affectsUs(): boolean {
    // Check right actor type
    let tf = this._typedFlags;
    if (this.parent instanceof LancerActor && tf?.lancer?.target_type) {
      switch (tf.lancer.target_type) {
        case EntryType.PILOT:
          return this.parent.is_pilot();
        case EntryType.MECH:
          return this.parent.is_mech();
        case EntryType.DEPLOYABLE:
          return this.parent.is_deployable();
        case EntryType.NPC:
          return this.parent.is_npc();
        case "mech_and_npc":
          return this.parent.is_mech() || this.parent.is_npc();
        case "only_deployable":
          return this.parent.is_deployable() && this.parent.system.type == DeployableType.Deployable;
        case "only_drone":
          return this.parent.is_deployable() && this.parent.system.type == DeployableType.Drone;
        default:
          return false;
      }
    }
    return true;
  }

  /* --------------------------------------------- */

  /**
   * Prepare the data structure for Active Effects which are currently applied to an Actor or Item.
   */
  static prepareActiveEffectCategories(
    actor: LancerActor
  ): Array<{ type: string; label: string; effects: LancerActiveEffect[] }> {
    // Define effect header categories
    let passives = {
      type: "passive",
      label: game.i18n.localize("lancer.effect.categories.passive"),
      effects: [] as LancerActiveEffect[],
    };
    let inherited = {
      type: "inherited",
      label: game.i18n.localize("lancer.effect.categories.inherited"),
      effects: [] as LancerActiveEffect[],
    };
    let disabled = {
      type: "disabled",
      label: game.i18n.localize("lancer.effect.categories.disabled"),
      effects: [] as LancerActiveEffect[],
    };
    let passthrough = {
      type: "passthrough",
      label: game.i18n.localize("lancer.effect.categories.passthrough"),
      effects: [] as LancerActiveEffect[],
    };

    // Iterate over active effects, classifying them into categories
    for (let e of actor.effects.contents as LancerActiveEffect[]) {
      // e._getSourceName(); // Trigger a lookup for the source name
      if (!e.affectsUs()) passthrough.effects.push(e);
      // @ts-expect-error
      else if (e.disabled) disabled.effects.push(e);
      else if (e._typedFlags.lancer?.deep_origin) inherited.effects.push(e);
      else passives.effects.push(e);
    }

    // categories.suppressed.hidden = !categories.suppressed.effects.length;
    return [passives, inherited, disabled, passthrough];
  }

  // Populate config with our static/compendium statuses instead of the builtin ones
  static async populateConfig(from_compendium: boolean) {
    const keepStock = game.settings.get(game.system.id, LANCER.setting_stock_icons);

    // @ts-expect-error TODO: Remove this expect when have v9 types
    let statuses: StatusEffect[] = [];
    if (keepStock) statuses = statuses.concat(CONFIG.statusEffects);
    if (from_compendium) {
      let pack = game.packs.get(`world.${EntryType.STATUS}`);
      let all_statuses = await pack?.getDocuments();
      if (all_statuses?.length) {
        // @ts-expect-error
        statuses = statuses.concat(all_statuses.map(statusConfigEffect));
      } else {
        statuses = statuses.concat(STATUSES);
      }
    } else {
      statuses = statuses.concat(STATUSES);
    }
    CONFIG.statusEffects = statuses;
  }
}

// To support more effects, we add several effect types.
export const AE_MODE_SET_JSON = 11 as any;
export const AE_MODE_APPEND_JSON = 12 as any;
const _json_cache = {} as Record<string, any>;
Hooks.on(
  "applyActiveEffect",
  function (actor: LancerActor, change: EffectChangeData, current: any, _delta: any, _changes: any) {
    if (change.mode == AE_MODE_SET_JSON || change.mode == AE_MODE_APPEND_JSON) {
      try {
        let parsed_delta = _json_cache[change.value] ?? JSON.parse(change.value);
        _json_cache[change.value] = parsed_delta;
        // Ok, now set it to wherever it was labeled
        if (change.mode == AE_MODE_SET_JSON) {
          foundry.utils.setProperty(actor, change.key, parsed_delta);
        } else if (change.mode == AE_MODE_APPEND_JSON) {
          foundry.utils.getProperty(actor, change.key).push(parsed_delta);
        }
      } catch (e) {
        // Nothing to do really, except log it
        console.warn(`JSON effect parse failed, ${change.value}`);
      }
    }
  }
);
